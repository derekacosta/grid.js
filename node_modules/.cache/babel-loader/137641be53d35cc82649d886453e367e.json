{"ast":null,"code":"import _defineProperty from \"/Users/standarduser/Documents/CompSci/Personals/grid.js/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"/Users/standarduser/Documents/CompSci/Personals/grid.js/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/Users/standarduser/Documents/CompSci/Personals/grid.js/src/Grid/Grid.tsx\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useState, useEffect } from \"react\";\nimport Cell from \"./Cell\";\n\nconst Grid = props => {\n  const col = props.col,\n        row = props.row,\n        cellHeight = props.cellHeight,\n        cellWidth = props.cellWidth;\n\n  const _useState = useState(),\n        _useState2 = _slicedToArray(_useState, 2),\n        grid = _useState2[0],\n        setGrid = _useState2[1];\n\n  const _useState3 = useState(false),\n        _useState4 = _slicedToArray(_useState3, 2),\n        mousePressed = _useState4[0],\n        setMousePressed = _useState4[1];\n\n  useEffect(() => {\n    setGrid(getInitialGrid(col, row));\n  }, [col, row]);\n\n  const handleMouseDown = (row, col) => {\n    setGrid(RefreshGrid(grid, row, col));\n    setMousePressed(true);\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (!mousePressed) return;\n    setGrid(RefreshGrid(grid, row, col));\n  };\n\n  const handleMouseUp = () => {\n    setMousePressed(false);\n  };\n\n  return React.createElement(\"svg\", {\n    style: {\n      height: \"50%\",\n      margin: \"0 auto\",\n      display: \"inline-block\",\n      borderCollapse: \"collapse\",\n      tableLayout: \"fixed\"\n    },\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 39\n    },\n    __self: this\n  }, grid && grid.map((row, rowIdx) => React.createElement(\"tr\", {\n    key: rowIdx,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 51\n    },\n    __self: this\n  }, row.map((node, nodeIdx) => {\n    const row = node.row,\n          col = node.col,\n          isWall = node.isWall;\n    return React.createElement(Cell, {\n      cellHeight: cellHeight,\n      cellWidth: cellWidth,\n      key: nodeIdx,\n      col: col,\n      row: row,\n      isWall: isWall,\n      mousePressed: mousePressed,\n      onMouseDown: (col, row) => handleMouseDown(row, col),\n      onMouseEnter: (col, row) => handleMouseEnter(row, col),\n      onMouseUp: (col, row) => handleMouseUp(),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 55\n      },\n      __self: this\n    });\n  }))));\n};\n\nconst getInitialGrid = (col, row) => {\n  const grid = [];\n\n  for (let i = 0; i < row; i++) {\n    const currentRow = [];\n\n    for (let j = 0; j < col; j++) {\n      currentRow.push(createNode(i, j));\n    }\n\n    grid.push(currentRow);\n  }\n\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    // isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    // isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null\n  };\n};\n\nconst RefreshGrid = (grid, row, col) => {\n  const newGrid = grid.slice(0);\n  const node = grid[row][col];\n\n  const newNode = _objectSpread({}, node, {\n    isWall: !node.isWall\n  });\n\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nexport default Grid;","map":{"version":3,"sources":["/Users/standarduser/Documents/CompSci/Personals/grid.js/src/Grid/Grid.tsx"],"names":["React","useState","useEffect","Cell","Grid","props","col","row","cellHeight","cellWidth","grid","setGrid","mousePressed","setMousePressed","getInitialGrid","handleMouseDown","RefreshGrid","handleMouseEnter","handleMouseUp","height","margin","display","borderCollapse","tableLayout","map","rowIdx","node","nodeIdx","isWall","i","currentRow","j","push","createNode","distance","Infinity","isVisited","previousNode","newGrid","slice","newNode"],"mappings":"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","sourcesContent":["import React, { useState, useEffect, useRef } from \"react\";\nimport { arrayOf, bool, func, number, shape, string } from \"prop-types\";\nimport { useDebouncedCallback } from \"use-debounce\";\nimport Cell from \"./Cell\";\n\ninterface Props {\n  // id: any;\n  col: Number;\n  row: Number;\n  cellHeight: Number;\n  cellWidth: Number;\n}\n\nconst Grid: React.FC<Props> = props => {\n  const { col, row, cellHeight, cellWidth } = props;\n\n  const [grid, setGrid] = useState();\n\n  const [mousePressed, setMousePressed] = useState(false);\n  useEffect(() => {\n    setGrid(getInitialGrid(col, row));\n  }, [col, row]);\n\n  const handleMouseDown = (row: any, col: any) => {\n    setGrid(RefreshGrid(grid, row, col));\n    setMousePressed(true);\n  };\n\n  const handleMouseEnter = (row: any, col: any) => {\n    if (!mousePressed) return;\n    setGrid(RefreshGrid(grid, row, col));\n  };\n\n  const handleMouseUp = () => {\n    setMousePressed(false);\n  };\n\n  return (\n    <svg\n      style={{\n        height: \"50%\",\n        margin: \"0 auto\",\n        display: \"inline-block\",\n        borderCollapse: \"collapse\",\n        tableLayout: \"fixed\"\n      }}\n    >\n      {/* <tbody> */}\n        {grid &&\n          grid.map((row: any, rowIdx: any) => (\n            <tr key={rowIdx}>\n              {row.map((node: any, nodeIdx: any) => {\n                const { row, col, isWall } = node;\n                return (\n                  <Cell\n                    cellHeight={cellHeight}\n                    cellWidth={cellWidth}\n                    key={nodeIdx}\n                    col={col}\n                    row={row}\n                    isWall={isWall}\n                    mousePressed={mousePressed}\n                    onMouseDown={(col: any, row: any) =>\n                      handleMouseDown(row, col)\n                    }\n                    onMouseEnter={(col: any, row: any) =>\n                      handleMouseEnter(row, col)\n                    }\n                    onMouseUp={(col: any, row: any) => handleMouseUp()}\n                  />\n                );\n              })}\n            </tr>\n          ))}\n      {/* </tbody> */}\n    </svg>\n  );\n};\n\nconst getInitialGrid = (col: any, row: any) => {\n  const grid = [];\n  for (let i = 0; i < row; i++) {\n    const currentRow = [];\n    for (let j = 0; j < col; j++) {\n      currentRow.push(createNode(i, j));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col: any, row: any) => {\n  return {\n    col,\n    row,\n    // isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    // isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null\n  };\n};\n\nconst RefreshGrid = (grid: any, row: any, col: any) => {\n  const newGrid = grid.slice(0);\n  const node = grid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nexport default Grid;\n"]},"metadata":{},"sourceType":"module"}